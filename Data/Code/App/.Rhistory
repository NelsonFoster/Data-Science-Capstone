par(mar = c(0,0,0,0))
PlotPolysOnStaticMap(MyMap, shp, lwd=2,
col = rgb(0.25,0.25,0.25,0.025), add = F)
g2 <- st_read("georgia.shp")
shp <- SpatialPolygons2PolySet(georgia.sub)
# determine the extent of the subset
bb <- qbbox(lat = shp[,"Y"], lon = shp[,"X"])
# download map data and store it
MyMap <- GetMap.bbox(bb$lonR, bb$latR, destfile = "DC.jpg")
# now plot the layer and the backdrop
par(mar = c(0,0,0,0))
PlotPolysOnStaticMap(MyMap, shp, lwd=2,
col = rgb(0.25,0.25,0.25,0.025), add = F)
shp <- SpatialPolygons2PolySet(georgia.sub)
install.packages(PBSmapping), binary=TRUE
install.packages(PBSmapping)
install.packages("PBSmapping")
shp <- SpatialPolygons2PolySet(georgia.sub)
data(newhaven)
ls()
# convert to sf
blocks_sf <- st_as_sf(blocks)
breach_sf <- st_as_sf(breach)
tracts_sf <- st_as_sf(tracts)
# have a look at the attributes and object class
summary(blocks_sf)
class(blocks_sf)
summary(breach_sf)
class(breach_sf)
summary(tracts_sf)
class(tracts_sf)
data.frame(blocks_sf)
colnames(blocks@data)
head(blocks@data)
colnames(blocks@data)
data.frame(blocks_sf$P_VACANT)
blocks$P_VACANT
attach(data.frame(blocks_sf))
hist(P_VACANT)
detach(data.frame(blocks_sf))
# use kde.points to create a kernel density surface
breach.dens = st_as_sf(kde.points(breach,lims=tracts))
summary(breach.dens)
```
breach.dens = st_as_sf(kde.points(breach,lims=tracts))
summary(breach.dens)
breach.dens
plot(breach.dens)
blocks_sf$RandVar <- rnorm(nrow(blocks_sf))
plot(breach.dens)
tmap_mode('plot')
tm_shape(blocks_sf) +
tm_polygons("P_OWNEROCC")
display.brewer.all()
tmap_mode('plot')
tm_shape(blocks_sf) +
tm_polygons("P_OWNEROCC")
data(quakes)
head(quakes)
# define the coordinates
coords.tmp <- cbind(quakes$long, quakes$lat)
# create the SpatialPointsDataFrame
quakes.sp <- SpatialPointsDataFrame(coords.tmp,
data = data.frame(quakes),
proj4string = CRS("+proj=longlat "))
# convert to sf
quakes_sf <- st_as_sf(quakes.sp)
plot(quakes.sf)
quakes_sf <- st_as_sf(quakes.sp)
plot(quakes.sf)
quakes_sf <- st_as_sf(quakes.sp)
plot(quakes_sf)
plot(sp)
plot(quakes.sp)
tm_shape(quakes_sf) +
tm_dots(size = 0.5, alpha = 0.3)
```
# by size
p1 <- tm_shape(quakes_sf) +
tm_bubbles("depth", scale = 1, shape = 19, alpha = 0.3,
title.size="Quake Depths")
# by colour
p2 <- tm_shape(quakes_sf) +
tm_dots("depth", shape = 19, alpha = 0.5, size = 0.6,
palette = "PuBuGn",
title="Quake Depths")
# Multiple plots using the grid package
grid.newpage()
# set up the layout
pushViewport(viewport(layout=grid.layout(1,2)))
# plot using he print command
print(p1, vp=viewport(layout.pos.col = 1, height = 5))
print(p2, vp=viewport(layout.pos.col = 2, height = 5))
# create the index
index <- quakes_sf$mag > 5.5
summary(index)
# select the subset assign to tmp
tmp <- quakes_sf[index,]
# plot the subset
tm_shape(tmp) +
tm_dots(col = brewer.pal(5, "Reds")[4], shape = 19,
alpha = 0.5, size = 1) +
tm_layout(title="Quakes > 5.5",
title.position = c("centre", "top"))
print(p2, vp=viewport(layout.pos.col = 2, height = 5))
# define Lat and Lon
Lat <- as.vector(quakes$lat)
Long <- as.vector(quakes$long)
# get the map tiles
# you will need to be online
MyMap <- MapBackground(lat=Lat, lon=Long)
# define a size vector
tmp <- 1+(quakes$mag - min(quakes$mag))/max(quakes$mag)
PlotOnStaticMap(MyMap,Lat,Long,cex=tmp,pch=1,col='#FB6A4A30')
MyMap <- openmap(ul,lr)
Lat <- as.vector(quakes$lat)
Long <- as.vector(quakes$long)
MyMap <- MapBackground(lat=Lat, lon=Long)
MyMap <- MapBackground(lat=Lat, lon=Long)
data(meuse.grid)
class(meuse.grid)
summary(meuse.grid)
summary(meuse.grid)
plot(meuse.grid$x, meuse.grid$y, asp = 1)
plot(meuse.grid$x, meuse.grid$y, asp = 1)
meuse.sp = SpatialPixelsDataFrame(points =
meuse.grid[c("x", "y")], data = meuse.grid,
proj4string = CRS("+init=epsg:28992"))
meuse.r <- as(meuse.sp, "RasterStack")
plot(meuse.r)
plot(meuse.sp[,5])
spplot(meuse.sp[, 3:4])
image(meuse.sp[, "dist"], col = rainbow(7))
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
col.regions=topo.colors(20))
```
plot(meuse.r)
plot(meuse.sp[,5])
spplot(meuse.sp[, 3:4])
image(meuse.sp[, "dist"], col = rainbow(7))
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
col.regions=topo.colors(20))
plot(meuse.r)
plot(meuse.sp[,5])
spplot(meuse.sp[, 3:4])
image(meuse.sp[, "dist"], col = rainbow(7))
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
col.regions=topo.colors(20))
# set the tmap mode to plot
tmap_mode('plot')
# map dist and ffreq attributes
tm_shape(meuse.r) +
tm_raster(col = c("dist", "ffreq"), title = c("Distance", "Flood Freq"),
palette = "Reds", style = c("kmeans", "cat"))
# set the tmap mode to view
tmap_mode('view')
# map the dist attribute
tm_shape(meuse.r) +
tm_raster(col = "dist", title = "Distance", style = "kmeans") +
tm_layout(legend.format = list(digits = 1))
tm_shape(meuse.r) +
tm_raster(col = "soil", title = "Soil",
palette = "Spectral", style = "cat") +
tm_scale_bar(width = 0.3) +
tm_compass(position = c(0.74, 0.05)) +
tm_layout(frame = F, title = "Meuse flood plain",
title.size = 2, title.position = c("0.2", "top"),
legend.hist.size = 0.5)
library(tidyverse)
library(reshape2)
library(reshape2)
hist(blocks$P_VACANT, breaks = 40, col = "cyan",
border = "salmon",
main = "The distribution of vacant property percentages",
xlab = "percentage vacant", xlim = c(0,40))
hist(blocks$P_VACANT, breaks = 40, col = "cyan",
border = "salmon",
main = "The distribution of vacant property percentages",
xlab = "percentage vacant", xlim = c(0,40))
ggplot(blocks@data, aes(P_VACANT)) +
geom_histogram(col = "salmon", fill = "cyan", bins = 40) +
xlab("percentage vacant") +
labs(title = "The distribution of vacant property percentages")
# a logical test
index <- blocks$P_VACANT > 10
# assigned to 2 high, 1 low
blocks$vac <- index + 1
blocks$vac <- factor(blocks$vac, labels = c("Low", "High"))
library(ggplot2)
ggplot(melt(blocks@data[, c("P_OWNEROCC", "P_WHITE", "P_BLACK", "vac")]),
aes(variable, value)) +
geom_boxplot() +
facet_wrap(~vac)
ggplot(melt(blocks@data[, c("P_OWNEROCC", "P_WHITE", "P_BLACK", "vac")]),
aes(variable, value)) +
geom_boxplot(colour = "yellow", fill = "wheat", alpha = 0.7) +
facet_wrap(~vac) +
xlab("") +
ylab("Percentage") +
theme_dark() +
ggtitle("Boxplot of High and Low property vacancies")
plot(blocks$P_VACANT/100, blocks$P_WHITE/100)
plot(blocks$P_VACANT/100, blocks$P_BLACK/100)
# assign some variables
p.vac <- blocks$P_VACANT/100
p.w <- blocks$P_WHITE/100
p.b <- blocks$P_BLACK/100
# bind these together
df <- data.frame(p.vac, p.w, p.b)
# fit regressions
mod.1 <- lm(p.vac ~ p.w, data = df)
mod.2 <- lm(p.vac ~ p.b, data = df)
summary(mod.1)
p1 <- ggplot(df,aes(p.vac, p.w))+
#stat_summary(fun.data=mean_cl_normal) +
geom_smooth(method='lm') +
geom_point() +
xlab("Proportion of Vacant Properties") +
ylab("Proporion White") +
labs(title = "Regression of Vacant Properties aginst Proportion White")
p2 <- ggplot(df,aes(p.vac, p.b))+
#stat_summary(fun.data=mean_cl_normal) +
geom_smooth(method='lm') +
geom_point() +
xlab("Proportion of Vacant Properties") +
ylab("Proporion Black") +
labs(title = "Regression of Vacant Properties aginst Proportion Black")
grid.newpage()
# set up the layout
pushViewport(viewport(layout=grid.layout(2,1)))
# plot using he print command
print(p1, vp=viewport(layout.pos.row = 1, height = 5))
print(p2, vp=viewport(layout.pos.row = 2, height = 5))
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
ggplot(data = df) +
stat_mosaic(aes(weight = value, x = product(Var2),
fill=factor(vac.10)), na.rm=TRUE) +
theme(axis.text.x=element_text(angle=-90, hjust= .1)) +
labs(y='Proportion of Vacant Properties', x = 'Ethnic group',
title="Mosaic Plot of Vacant Properties with ethnicty") +
guides(fill=guide_legend(title = "> 10 percent", reverse = TRUE))
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
gplot(data = df) +
stat_mosaic(aes(weight = value, x = product(Var2),
fill=factor(vac.10)), na.rm=TRUE) +
theme(axis.text.x=element_text(angle=-90, hjust= .1)) +
labs(y='Proportion of Vacant Properties', x = 'Ethnic group',
title="Mosaic Plot of Vacant Properties with ethnicty") +
guides(fill=guide_legend(title = "> 10 percent", reverse = TRUE))
library(ggplot)
library(ggplot2)
# create the dataset
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
ggplot(data = df) +
stat_mosaic(aes(weight = value, x = product(Var2),
fill=factor(vac.10)), na.rm=TRUE) +
theme(axis.text.x=element_text(angle=-90, hjust= .1)) +
labs(y='Proportion of Vacant Properties', x = 'Ethnic group',
title="Mosaic Plot of Vacant Properties with ethnicty") +
guides(fill=guide_legend(title = "> 10 percent", reverse = TRUE))
library(GIStools)
data(tornados)
install.packages("GISTools")
library(GIStools)
data(tornados)
library(GIStools)
library(shiny)
library(glmnet)
library(GWmodel)
library(ISLR)
library(plotmo)
library(gradDescent)
library(caret)
library(dplyr)
library(sp)
library(sf)
library(GISTools)
library(OpenStreetMap)
library(raster)
library(rgdal)
library(colorspace)
library(maptools)
library(devtools)
library(r2d3)
library(R2HTML)
library(plotly)
library(ggplot2)
library(ggmap)
library(shinydashboard)
library(shinydashboardPlus)
library(grid)
library(ggmosaic)
library(spdep)
library(grid)
library(RgoogleMaps)
library(tmap, tmaptools)
library(tidyverse)
library(reshape2)
library(GISTools)
data(tornados)
# convert to sf objects
torn_sf <- st_as_sf(torn)
us_states_sf <- st_as_sf(us_states)
# plot extent and grey background
tm_shape(us_states_sf) +
tm_polygons("grey90") +
# add the torn points
tm_shape(torn_sf) +
tm_dots(col = "#FB6A4A", size = 0.04, shape = 1, alpha = 0.5) +
# map the state borders
tm_shape(us_states_sf) +
tm_borders(col = "black") +
tm_layout(frame = F)
ls()
plot(us_states, col = "grey90")
plot(torn, add = T, pch = 1, col = "#FB6A4A4C", cex = 0.4)
plot(us_states, add = T)
summary(sf)
summary(torn)
summary(torn)
summary(torn_sf)
st_geometry(torn_sf)
index <- us_states$STATE_NAME == "Texas" |
us_states$STATE_NAME == "New Mexico" |
us_states$STATE_NAME == "Oklahoma" |
us_states$STATE_NAME == "Arkansas"
AoI <- us_states[index,]
# OR....
AoI_sf <- us_states_sf[index,]
tm_shape(AoI_sf) +
tm_borders(col = "black") +
tm_layout(frame = F) +
# add the torn points
tm_shape(torn_sf) +
tm_dots(col = "#FB6A4A", size = 0.2, shape = 1, alpha = 0.5)
# OR in sp
plot(AoI)
plot(torn, add = T, pch = 1, col = "#FB6A4A4C")
torn_clip_sf <- torn_sf[AoI_sf,]
ls(STATE_NAME)
library(spatstat)
library(spdep)
# Load GISTools (for the data) and tmap (for the mapping)
require(GISTools)
require(tmap)
# Get the data
data(newhaven)
# look at it
# select 'view' mode
tmap_mode('view')
# Create the map of blocks and incidents
tm_shape(blocks) + tm_borders() + tm_shape(breach) +
tm_dots(col='navyblue')
choose_bw <- function(spdf) {
X <- coordinates(spdf)
sigma <- c(sd(X[,1]),sd(X[,2]))  * (2 / (3 * nrow(X))) ^ (1/6)
return(sigma/1000)
}
library(tmaptools)
tmap_mode('view')
breach_dens <- smooth_map(breach,cover=blocks, bandwidth = choose_bw(breach))
tm_shape(breach_dens$raster) + tm_raster()
library(tmaptools)
tmap_mode('view')
breach_dens <- smooth_map(breach,cover=blocks, bandwidth = choose_bw(breach))
tm_shape(breach_dens$raster) + tm_raster()
# R Kernel Density comparison - first make sure the New Haven data is available
require(GISTools)
data(newhaven)
tmap_mode('plot')
# Create the KDEs for the two data sets:
contours <- seq(0,1.4,by=0.2)
brn_dens <- smooth_map(burgres.n,cover=blocks, breaks=contours,
style='fixed',
bandwidth = choose_bw(burgres.n))
brf_dens <- smooth_map(burgres.f,cover=blocks, breaks=contours,
style='fixed',
bandwidth = choose_bw(burgres.f))
dn <- tm_shape(blocks) + tm_borders() +
tm_shape(brn_dens$polygons) + tm_fill(col='level',alpha=0.8) +
tm_layout(title="Non-Forced Burglaries")
df <- tm_shape(blocks) + tm_borders() +
tm_shape(brf_dens$polygons) + tm_fill(col='level',alpha=0.8) +
tm_layout(title="Forced Burglaries")
tmap_arrange(dn,df)
tmap_mode('view')
tm_shape(blocks) + tm_borders(alpha=0.5) +
tm_shape(breach_dens$iso) + tm_lines(col='darkred', lwd=2)
setwd("~/Documents/GitHub/Data-Science-Capstone/Data/Code/App")
library(shiny)
library(leaflet)
library(dplyr)
library(tidyr)
library(tidyverse)
library(tidycensus)
library(tigris)
options(tigris_use_cache = TRUE)
library(sf)
library(sp)
library(censusapi)
library(shiny)
library(leaflet)
library(dplyr)
library(tidyr)
library(tidyverse)
library(tidycensus)
library(tigris)
options(tigris_use_cache = TRUE)
library(sf)
library(sp)
library(censusapi)
states <- states(cb=T)
states %>%
leaflet() %>%
addTiles() %>%
addPolygons(popup=~NAME)
df = read.csv("./mp_points.csv", stringsAsFactors = F)
df <- tidyr::separate(data=df,
col=geo_point_2d,
into=c("Latitude", "Longitude"),
sep=",",
remove=FALSE)
df$Latitude <- stringr::str_replace_all(df$Latitude, "[(]", "")
df$Longitude <- stringr::str_replace_all(df$Longitude, "[)]", "")
df$Latitude <- as.numeric(df$Latitude)
df$Longitude <- as.numeric(df$Longitude)
mp_state <- df %>%
group_by(State_Of_Last_Contact) %>%
summarize(total=n()) %>%
mutate(type = "Missing Persons")
states_merged_mp <- geo_join(states, mp_state, "STUSPS", "State_Of_Last_Contact")
pal <- colorNumeric("Blues", domain=states_merged_mp$total)
states_merged_mp <- subset(states_merged_mp, !is.na(total))
popup_mp <- paste0("Total Missing Persons: ", as.character(states_merged_mp$total))
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
setView(-98.483330, 38.712046, zoom = 4) %>% #geographic center of the United States
addPolygons(data = states_merged_mp ,
fillColor = ~pal(states_merged_mp$total),
fillOpacity = 0.7,
weight = 0.2,
smoothFactor = 0.2,
popup = ~popup_mp) %>%
addLegend(pal = pal,
values = states_merged_mp$total,
position = "bottomright",
title = "Missing Persons in the United States")
Sys.setenv(CENSUS_KEY="31fff949176a736010c1e360cacac97f81c300b8")
readRenviron("~/.Renviron")
Sys.getenv("CENSUS_KEY")
state_pop <-  getCensus(name="acs/acs5",
vintage=2015,
key=census_key,
vars=c("NAME", "B01003_001E"),
region="state:*")
state_pop <-  getCensus(name="acs/acs5",
vintage=2015,
key=CENSUS_KEY,
vars=c("NAME", "B01003_001E"),
region="state:*")
Sys.setenv(census_key="31fff949176a736010c1e360cacac97f81c300b8")
readRenviron("~/.Renviron")
Sys.getenv("census_key")
state_pop <-  getCensus(name="acs/acs5",
vintage=2015,
key=census_key,
vars=c("NAME", "B01003_001E"),
region="state:*")
Sys.setenv(CENSUS_KEY=31fff949176a736010c1e360cacac97f81c300b8)
Sys.setenv(CENSUS_KEY="31fff949176a736010c1e360cacac97f81c300b8")
readRenviron("~/.Renviron")
readRenviron("~/.Renviron")
Sys.getenv("CENSUS_KEY")
state_pop <-  getCensus(name="acs/acs5",
vintage=2015,
key=census_key,
vars=c("NAME", "B01003_001E"),
region="state:*")
