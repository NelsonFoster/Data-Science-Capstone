plot(quakes.sf)
quakes_sf <- st_as_sf(quakes.sp)
plot(quakes_sf)
plot(sp)
plot(quakes.sp)
tm_shape(quakes_sf) +
tm_dots(size = 0.5, alpha = 0.3)
```
# by size
p1 <- tm_shape(quakes_sf) +
tm_bubbles("depth", scale = 1, shape = 19, alpha = 0.3,
title.size="Quake Depths")
# by colour
p2 <- tm_shape(quakes_sf) +
tm_dots("depth", shape = 19, alpha = 0.5, size = 0.6,
palette = "PuBuGn",
title="Quake Depths")
# Multiple plots using the grid package
grid.newpage()
# set up the layout
pushViewport(viewport(layout=grid.layout(1,2)))
# plot using he print command
print(p1, vp=viewport(layout.pos.col = 1, height = 5))
print(p2, vp=viewport(layout.pos.col = 2, height = 5))
# create the index
index <- quakes_sf$mag > 5.5
summary(index)
# select the subset assign to tmp
tmp <- quakes_sf[index,]
# plot the subset
tm_shape(tmp) +
tm_dots(col = brewer.pal(5, "Reds")[4], shape = 19,
alpha = 0.5, size = 1) +
tm_layout(title="Quakes > 5.5",
title.position = c("centre", "top"))
print(p2, vp=viewport(layout.pos.col = 2, height = 5))
# define Lat and Lon
Lat <- as.vector(quakes$lat)
Long <- as.vector(quakes$long)
# get the map tiles
# you will need to be online
MyMap <- MapBackground(lat=Lat, lon=Long)
# define a size vector
tmp <- 1+(quakes$mag - min(quakes$mag))/max(quakes$mag)
PlotOnStaticMap(MyMap,Lat,Long,cex=tmp,pch=1,col='#FB6A4A30')
MyMap <- openmap(ul,lr)
Lat <- as.vector(quakes$lat)
Long <- as.vector(quakes$long)
MyMap <- MapBackground(lat=Lat, lon=Long)
MyMap <- MapBackground(lat=Lat, lon=Long)
data(meuse.grid)
class(meuse.grid)
summary(meuse.grid)
summary(meuse.grid)
plot(meuse.grid$x, meuse.grid$y, asp = 1)
plot(meuse.grid$x, meuse.grid$y, asp = 1)
meuse.sp = SpatialPixelsDataFrame(points =
meuse.grid[c("x", "y")], data = meuse.grid,
proj4string = CRS("+init=epsg:28992"))
meuse.r <- as(meuse.sp, "RasterStack")
plot(meuse.r)
plot(meuse.sp[,5])
spplot(meuse.sp[, 3:4])
image(meuse.sp[, "dist"], col = rainbow(7))
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
col.regions=topo.colors(20))
```
plot(meuse.r)
plot(meuse.sp[,5])
spplot(meuse.sp[, 3:4])
image(meuse.sp[, "dist"], col = rainbow(7))
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
col.regions=topo.colors(20))
plot(meuse.r)
plot(meuse.sp[,5])
spplot(meuse.sp[, 3:4])
image(meuse.sp[, "dist"], col = rainbow(7))
spplot(meuse.sp, c("part.a", "part.b", "soil", "ffreq"),
col.regions=topo.colors(20))
# set the tmap mode to plot
tmap_mode('plot')
# map dist and ffreq attributes
tm_shape(meuse.r) +
tm_raster(col = c("dist", "ffreq"), title = c("Distance", "Flood Freq"),
palette = "Reds", style = c("kmeans", "cat"))
# set the tmap mode to view
tmap_mode('view')
# map the dist attribute
tm_shape(meuse.r) +
tm_raster(col = "dist", title = "Distance", style = "kmeans") +
tm_layout(legend.format = list(digits = 1))
tm_shape(meuse.r) +
tm_raster(col = "soil", title = "Soil",
palette = "Spectral", style = "cat") +
tm_scale_bar(width = 0.3) +
tm_compass(position = c(0.74, 0.05)) +
tm_layout(frame = F, title = "Meuse flood plain",
title.size = 2, title.position = c("0.2", "top"),
legend.hist.size = 0.5)
library(tidyverse)
library(reshape2)
library(reshape2)
hist(blocks$P_VACANT, breaks = 40, col = "cyan",
border = "salmon",
main = "The distribution of vacant property percentages",
xlab = "percentage vacant", xlim = c(0,40))
hist(blocks$P_VACANT, breaks = 40, col = "cyan",
border = "salmon",
main = "The distribution of vacant property percentages",
xlab = "percentage vacant", xlim = c(0,40))
ggplot(blocks@data, aes(P_VACANT)) +
geom_histogram(col = "salmon", fill = "cyan", bins = 40) +
xlab("percentage vacant") +
labs(title = "The distribution of vacant property percentages")
# a logical test
index <- blocks$P_VACANT > 10
# assigned to 2 high, 1 low
blocks$vac <- index + 1
blocks$vac <- factor(blocks$vac, labels = c("Low", "High"))
library(ggplot2)
ggplot(melt(blocks@data[, c("P_OWNEROCC", "P_WHITE", "P_BLACK", "vac")]),
aes(variable, value)) +
geom_boxplot() +
facet_wrap(~vac)
ggplot(melt(blocks@data[, c("P_OWNEROCC", "P_WHITE", "P_BLACK", "vac")]),
aes(variable, value)) +
geom_boxplot(colour = "yellow", fill = "wheat", alpha = 0.7) +
facet_wrap(~vac) +
xlab("") +
ylab("Percentage") +
theme_dark() +
ggtitle("Boxplot of High and Low property vacancies")
plot(blocks$P_VACANT/100, blocks$P_WHITE/100)
plot(blocks$P_VACANT/100, blocks$P_BLACK/100)
# assign some variables
p.vac <- blocks$P_VACANT/100
p.w <- blocks$P_WHITE/100
p.b <- blocks$P_BLACK/100
# bind these together
df <- data.frame(p.vac, p.w, p.b)
# fit regressions
mod.1 <- lm(p.vac ~ p.w, data = df)
mod.2 <- lm(p.vac ~ p.b, data = df)
summary(mod.1)
p1 <- ggplot(df,aes(p.vac, p.w))+
#stat_summary(fun.data=mean_cl_normal) +
geom_smooth(method='lm') +
geom_point() +
xlab("Proportion of Vacant Properties") +
ylab("Proporion White") +
labs(title = "Regression of Vacant Properties aginst Proportion White")
p2 <- ggplot(df,aes(p.vac, p.b))+
#stat_summary(fun.data=mean_cl_normal) +
geom_smooth(method='lm') +
geom_point() +
xlab("Proportion of Vacant Properties") +
ylab("Proporion Black") +
labs(title = "Regression of Vacant Properties aginst Proportion Black")
grid.newpage()
# set up the layout
pushViewport(viewport(layout=grid.layout(2,1)))
# plot using he print command
print(p1, vp=viewport(layout.pos.row = 1, height = 5))
print(p2, vp=viewport(layout.pos.row = 2, height = 5))
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
ggplot(data = df) +
stat_mosaic(aes(weight = value, x = product(Var2),
fill=factor(vac.10)), na.rm=TRUE) +
theme(axis.text.x=element_text(angle=-90, hjust= .1)) +
labs(y='Proportion of Vacant Properties', x = 'Ethnic group',
title="Mosaic Plot of Vacant Properties with ethnicty") +
guides(fill=guide_legend(title = "> 10 percent", reverse = TRUE))
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
gplot(data = df) +
stat_mosaic(aes(weight = value, x = product(Var2),
fill=factor(vac.10)), na.rm=TRUE) +
theme(axis.text.x=element_text(angle=-90, hjust= .1)) +
labs(y='Proportion of Vacant Properties', x = 'Ethnic group',
title="Mosaic Plot of Vacant Properties with ethnicty") +
guides(fill=guide_legend(title = "> 10 percent", reverse = TRUE))
library(ggplot)
library(ggplot2)
# create the dataset
pops <- data.frame(blocks[,14:18]) * data.frame(blocks)[,11]
pops <- as.matrix(pops/100)
colnames(pops) <- c("White", "Black", "Ameri", "Asian", "Other")
# a true / false for vacant properties
vac.10 <- (blocks$P_VACANT > 10)
# create a cross tabulation
mat.tab <- xtabs(pops ~vac.10)
# melt the data
df <- melt(mat.tab)
ggplot(data = df) +
stat_mosaic(aes(weight = value, x = product(Var2),
fill=factor(vac.10)), na.rm=TRUE) +
theme(axis.text.x=element_text(angle=-90, hjust= .1)) +
labs(y='Proportion of Vacant Properties', x = 'Ethnic group',
title="Mosaic Plot of Vacant Properties with ethnicty") +
guides(fill=guide_legend(title = "> 10 percent", reverse = TRUE))
library(GIStools)
data(tornados)
install.packages("GISTools")
library(GIStools)
data(tornados)
library(GIStools)
library(shiny)
library(glmnet)
library(GWmodel)
library(ISLR)
library(plotmo)
library(gradDescent)
library(caret)
library(dplyr)
library(sp)
library(sf)
library(GISTools)
library(OpenStreetMap)
library(raster)
library(rgdal)
library(colorspace)
library(maptools)
library(devtools)
library(r2d3)
library(R2HTML)
library(plotly)
library(ggplot2)
library(ggmap)
library(shinydashboard)
library(shinydashboardPlus)
library(grid)
library(ggmosaic)
library(spdep)
library(grid)
library(RgoogleMaps)
library(tmap, tmaptools)
library(tidyverse)
library(reshape2)
library(GISTools)
data(tornados)
# convert to sf objects
torn_sf <- st_as_sf(torn)
us_states_sf <- st_as_sf(us_states)
# plot extent and grey background
tm_shape(us_states_sf) +
tm_polygons("grey90") +
# add the torn points
tm_shape(torn_sf) +
tm_dots(col = "#FB6A4A", size = 0.04, shape = 1, alpha = 0.5) +
# map the state borders
tm_shape(us_states_sf) +
tm_borders(col = "black") +
tm_layout(frame = F)
ls()
plot(us_states, col = "grey90")
plot(torn, add = T, pch = 1, col = "#FB6A4A4C", cex = 0.4)
plot(us_states, add = T)
summary(sf)
summary(torn)
summary(torn)
summary(torn_sf)
st_geometry(torn_sf)
index <- us_states$STATE_NAME == "Texas" |
us_states$STATE_NAME == "New Mexico" |
us_states$STATE_NAME == "Oklahoma" |
us_states$STATE_NAME == "Arkansas"
AoI <- us_states[index,]
# OR....
AoI_sf <- us_states_sf[index,]
tm_shape(AoI_sf) +
tm_borders(col = "black") +
tm_layout(frame = F) +
# add the torn points
tm_shape(torn_sf) +
tm_dots(col = "#FB6A4A", size = 0.2, shape = 1, alpha = 0.5)
# OR in sp
plot(AoI)
plot(torn, add = T, pch = 1, col = "#FB6A4A4C")
torn_clip_sf <- torn_sf[AoI_sf,]
ls(STATE_NAME)
library(spatstat)
library(spdep)
# Load GISTools (for the data) and tmap (for the mapping)
require(GISTools)
require(tmap)
# Get the data
data(newhaven)
# look at it
# select 'view' mode
tmap_mode('view')
# Create the map of blocks and incidents
tm_shape(blocks) + tm_borders() + tm_shape(breach) +
tm_dots(col='navyblue')
choose_bw <- function(spdf) {
X <- coordinates(spdf)
sigma <- c(sd(X[,1]),sd(X[,2]))  * (2 / (3 * nrow(X))) ^ (1/6)
return(sigma/1000)
}
library(tmaptools)
tmap_mode('view')
breach_dens <- smooth_map(breach,cover=blocks, bandwidth = choose_bw(breach))
tm_shape(breach_dens$raster) + tm_raster()
library(tmaptools)
tmap_mode('view')
breach_dens <- smooth_map(breach,cover=blocks, bandwidth = choose_bw(breach))
tm_shape(breach_dens$raster) + tm_raster()
# R Kernel Density comparison - first make sure the New Haven data is available
require(GISTools)
data(newhaven)
tmap_mode('plot')
# Create the KDEs for the two data sets:
contours <- seq(0,1.4,by=0.2)
brn_dens <- smooth_map(burgres.n,cover=blocks, breaks=contours,
style='fixed',
bandwidth = choose_bw(burgres.n))
brf_dens <- smooth_map(burgres.f,cover=blocks, breaks=contours,
style='fixed',
bandwidth = choose_bw(burgres.f))
dn <- tm_shape(blocks) + tm_borders() +
tm_shape(brn_dens$polygons) + tm_fill(col='level',alpha=0.8) +
tm_layout(title="Non-Forced Burglaries")
df <- tm_shape(blocks) + tm_borders() +
tm_shape(brf_dens$polygons) + tm_fill(col='level',alpha=0.8) +
tm_layout(title="Forced Burglaries")
tmap_arrange(dn,df)
tmap_mode('view')
tm_shape(blocks) + tm_borders(alpha=0.5) +
tm_shape(breach_dens$iso) + tm_lines(col='darkred', lwd=2)
library(leaflet)
library(dplyr)
library(tidyr)
library(tidyverse)
library(maps)
library(GISTools)
library(tmap)
library(raster)
library(spatstat)
library(rgdal)
library(sf)
library(sp)
library(data.table)
df = read.csv("./mp_points.csv", stringsAsFactors = F)
df <- tidyr::separate(data=df,
col=geo_point_2d,
into=c("Latitude", "Longitude"),
sep=",",
remove=FALSE)
df$Latitude <- stringr::str_replace_all(df$Latitude, "[(]", "")
df$Longitude <- stringr::str_replace_all(df$Longitude, "[)]", "")
library(tidyr)
library(tidyverse)
df = read.csv("./mp_points.csv", stringsAsFactors = F)
setwd("~/Documents/GitHub/Data-Science-Capstone/Data/Code/App")
df = read.csv("./mp_points.csv", stringsAsFactors = F)
df <- tidyr::separate(data=df,
col=geo_point_2d,
into=c("Latitude", "Longitude"),
sep=",",
remove=FALSE)
df$Latitude <- stringr::str_replace_all(df$Latitude, "[(]", "")
df$Longitude <- stringr::str_replace_all(df$Longitude, "[)]", "")
df$Latitude <- as.numeric(df$Latitude)
df$Longitude <- as.numeric(df$Longitude)
saveRDS(df, "./data.rds")
sample_data <- df
saveRDS(sample_data, "./sample_data.rds")
shiny::runApp('~/Desktop/App')
library(shiny)
library(leaflet)
library(dplyr)
library(ggplot2)
mp_by_state <- dplyr::tbl_df(df)
View(df)
View(mp_by_state)
colnames(df)
by_state <- group_by(df, State_Of_Last_Contact)
View(by_state)
library(plyr)
library(plyr)
colnames(df)
count(df, id_Formatted )
count(df, "id_Formatted" )
count(df$State_Of_Last_Contact, "id_Formatted" )
count(df, "State_Of_Last_Contact" )
colnames(df)
count(df, "id_Formatted", "State_Of_Last_Contact" )
count(df, c("State_Of_Last_Contact", "id_Formatted"))
aggregate(id_Formatted ~ State_Of_Last_Contact, data = df, count)
colnames(df)
library(reshape)
cast(df, id_Formatted ~ State_Of_Last_Contact)
class(df)
class(by_State)
class(by_state)
by_state %>% group_by(State_Of_Last_Contact) %>% summarize(id_Formatted=count(id_Formatted))
by_state %>% group_by(State_Of_Last_Contact) %>% summarize(id_Formatted=sum(id_Formatted))
count(State_Of_Last_Contact)
library(reshape2)
class(mp_by_state)
dcast(data = mp_by_state, fun.aggregate = count, value.var = id_Formatted)
View(by_state)
View(mp_by_state)
table(mp_by_state[c(1, 3)])
mp_by_state %>%
group_by(State_Of_Last_Contact) %>%
summarise(val=count(id_Formatted)) %>%
spread(State_Of_Last_Contact)
colnames(mp_by_state)
mp_by_state %>%
group_by(State_Of_Last_Contact) %>%
+ summarise(val=count(id_Formatted)) %>%
+ spread(State_Of_Last_Contact)
mp_by_state %>%
group_by(State_Of_Last_Contact, id_Formatted) %>%
summarise(val=count(val)) %>%
spread(id_Formatted, val)
mp_by_state %>%
group_by(State_Of_Last_Contact, id_Formatted) %>%
summarise(id_Formatted=count(id_Formatted)) %>%
spread(State_Of_Last_Contact, id_Formatted)
mp_by_state %>%
group_by(mp_by_State$State_Of_Last_Contact, mp_by_State$id_Formatted) %>%
summarise(mp_by_State$id_Formatted=count(mp_by_State$id_Formatted)) %>%
spread(mp_by_State$State_Of_Last_Contact, mp_by_State$id_Formatted)
mp_by_state %>%
group_by(mp_by_state$state_Of_Last_Contact, mp_by_state$id_Formatted) %>%
summarise(mp_by_state$id_Formatted=count(mp_by_state$id_Formatted)) %>%
spread(mp_by_state$state_Of_Last_Contact, mp_by_state$id_Formatted)
mp_by_state %>%
group_by(mp_by_state$State_Of_Last_Contact, mp_by_state$id_Formatted) %>%
summarise(mp_by_state$id_Formatted=count(mp_by_state$id_Formatted)) %>%
spread(mp_by_state$State_Of_Last_Contact, mp_by_state$id_Formatted)
table(mp_by_state$State_Of_Last_Contact)
data.frame(table(mp_by_state$State_Of_Last_Contact))
data.frame(table(mp_by_state$State_Of_Last_Contact, mp_by_state$Race_Ethnicity))
test_tbl <- data.frame(table(mp_by_state$State_Of_Last_Contact, mp_by_state$Race_Ethnicity))
View(test_tbl)
test_tbl <- data.frame(table(mp_by_state$State_Of_Last_Contact))
View(test_tbl)
missing_city <- data.frame(table(mp_by_state$City_Of_Last_Contact)
missing_city <- data.frame(table(mp_by_state$City_Of_Last_Contact))
missing_county <- data.frame(mp_by_state$County_Of_Last_Contact)
missing_demographics <- mp_by_state %>%
count(State_Of_Last_Contact, Race_Ethnicity, sort = TRUE)
missing_demographics <- mp_by_state %>%
count(State_Of_Last_Contact, Race_Ethnicity)
missing_demographics <- mp_by_state %>%
count(mp_by_state$State_Of_Last_Contact, mp_by_state$Race_Ethnicity)
rownames(mp_by_state$State_Of_Last_Contact)
colnames(mp_by_state$State_Of_Last_Contact)
missing_county <- data.frame(table(mp_by_state$County_Of_Last_Contact))
Race_ethnicity <- data.frame(table(mp_by_state$Race_Ethnicity))
View(Race_ethnicity)
missing_state <- data.frame(table(mp_by_state$State_Of_Last_Contact))
runApp('~/Desktop/App')
View(by_state)
table(mp_by_state$State_Of_Last_Contact)
by_state <- table(mp_by_state$State_Of_Last_Contact)
runApp('~/Desktop/App')
runApp('~/Desktop/App')
mp_shp <- st_read("namus-missings.shp")
utm18nCRS <- st_crs(mp_shp)
df_points <- st_as_sf(df, coords = c("Longitude", "Latitude"), crs = utm18nCRS)
st_crs(df_points)
class(df_points)
plot(df_points$geometry, pch = 20, col = "steelblue")
library(tmap)
qtm(df_points$geometry, fill = "steelblue", style = "natural")
st_write(point_reference_mp,
"point_reference_mp.shp", driver = "ESRI Shapefile")
st_write(point_reference_mp,
"df_points.shp", driver = "ESRI Shapefile")
st_write(df_points,
"df_points.shp", driver = "ESRI Shapefile")
df_shp <- st_read("df_points.shp")
install.packages("tidycensus")
library(tidyverse)
library(tidycensus)
options(tigris_use_cache = TRUE)
v17 <-load_variables(2017, "acs5", cache = TRUE)
usa <- spData::us_states #map of contiguous United States with census population data
class(usa)
colnames(usa)
plot(df_shp$geometry, pch = 20, col = "steelblue")
plot(usa$geometry, pch = 20, col = "steelblue")
plot(usa$geometry, pch = 20, col = "grey")
us_pop <- get_acs(us)
